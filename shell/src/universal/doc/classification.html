<!-- Google Analytics -->
<script src="js/google-analytics.js" type="text/javascript"></script>

<!-- prettify js and CSS -->
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=scala"></script>

<!-- scroll/follow sidebar -->
<script src="js/follow-sidebar.js" type="text/javascript"></script>

<div class="col-md-3 col-md-push-9">
    <div id="sidebar">
        <div class="sidebar-toc" style="margin-bottom: 20px;">
            <p class="toc-header">Contents</p>
            <div id="toc"></div>
        </div>
    </div>
</div>

<div class="col-md-9 col-md-pull-3">
    <h1 id="classification-top" class="title">Classification</h1>

    <p>Smile's classification algorithms are in the package
        <a href="api/java/smile/classification/package-summary.html"><code>smile.classification</code></a>
        and all algorithms implement the interface
        <a href="api/java/smile/classification/Classifier.html"><code>Classifier</code></a>
        that has a method <code>predict</code> to predict the class label of an instance.
        An overloaded version in <a href="api/java/smile/classification/SoftClassifier.html"><code>SoftClassifier</code></a>
        can also calculate the <i>a posteriori</i>
        probabilities besides the class label.
        For all algorithms, the model can be trained through
        the constructor. Meanwhile, each algorithm has a <code>Trainer</code> companion
        class that can hold model hyper-parameters and be applied to multiple training
        datasets.</p>

    <p>Some algorithms with online learning capability also implement the interface
        <a href="api/java/smile/classification/OnlineClassifier.html"><code>OnlineClassifier</code></a>
        Online learning is a model of induction that learns one instance at a time.
        The method <code>learn</code> updates the model with a new instance.</p>

    <p>The high-level operators are defined in Scala trait
        <a href="api/scala/index.html#smile.classification.Operators"><code>smile.classification.Operators</code></a>
        and also in the package object of <a href="api/scala/index.html#smile.classification.package"><code>smile.classification</code></a>.</p>

    <p>In what follows, we will discuss each algorithm, their high-level
        Scala API, and examples.</p>

    <h2 id="introduction">Introduction</h2>

    <p>In machine learning and pattern recognition,
        classification refers to an algorithmic procedure for assigning a given
        input object into one of a given number of categories. The input
        object is formally termed an instance, and the categories are termed classes.</p>
        
    <p>The instance is usually described by a vector of features, which together
        constitute a description of all known characteristics of the instance.
        Typically, features are either categorical (also known as nominal, i.e.
        consisting of one of a set of unordered items, such as a gender of "male"
        or "female", or a blood type of "A", "B", "AB" or "O"), ordinal (consisting
        of one of a set of ordered items, e.g. "large", "medium" or "small"),
        integer-valued (e.g. a count of the number of occurrences of a particular
        word in an email) or real-valued (e.g. a measurement of blood pressure).</p>
        
    <p>Classification normally refers to a supervised procedure, i.e. a procedure
        that produces an inferred function to predict the output value of new
        instances based on a training set of pairs consisting of an input object
        and a desired output value. The inferred function is called a classifier
        if the output is discrete or a regression function if the output is
        continuous.</p>
        
    <p>The inferred function should predict the correct output value for any valid
        input object. This requires the learning algorithm to generalize from the
        training data to unseen situations in a "reasonable" way.</p>
        
    <p>A wide range of supervised learning algorithms is available, each with
        its strengths and weaknesses. There is no single learning algorithm that
        works best on all supervised learning problems. The most widely used
        learning algorithms are AdaBoost and gradient boosting, support vector
        machines, linear regression, linear discriminant analysis, logistic
        regression, naive Bayes, decision trees, k-nearest neighbor algorithm,
        and neural networks (multilayer perceptron).</p>
        
    <p>If the feature vectors include features of many different kinds (discrete,
        discrete ordered, counts, continuous values), some algorithms cannot be
        easily applied. Many algorithms, including linear regression, logistic
        regression, neural networks, and nearest neighbor methods, require that
        the input features be numerical and scaled to similar ranges (e.g., to
        the [-1,1] interval). Methods that employ a distance function, such as
        nearest neighbor methods and support vector machines with Gaussian kernels,
        are particularly sensitive to this. An advantage of decision trees (and
        boosting algorithms based on decision trees) is that they easily handle
        heterogeneous data.</p>
        
    <p>If the input features contain redundant information (e.g., highly correlated
        features), some learning algorithms (e.g., linear regression, logistic
        regression, and distance based methods) will perform poorly because of
        numerical instabilities. These problems can often be solved by imposing
        some form of regularization.</p>
        
    <p>If each of the features makes an independent contribution to the output,
        then algorithms based on linear functions (e.g., linear regression,
        logistic regression, linear support vector machines, naive Bayes) generally
        perform well. However, if there are complex interactions among features,
        then algorithms such as nonlinear support vector machines, decision trees
        and neural networks work better. Linear methods can also be applied, but
        the engineer must manually specify the interactions when using them.</p>
        
    <p>There are several major issues to consider in supervised learning:</p>
    <dl>
        <dt>Features</dt>
        <dd><p>The accuracy of the inferred function depends strongly on how the input
            object is represented. Typically, the input object is transformed into
            a feature vector, which contains a number of features that are descriptive
            of the object. The number of features should not be too large, because of
            the curse of dimensionality; but should contain enough information to
            accurately predict the output.</p>

            <p>There are many algorithms for feature selection that seek to identify
            the relevant features and discard the irrelevant ones. More generally,
            dimensionality reduction may seek to map the input data into a lower
            dimensional space prior to running the supervised learning algorithm.</p>
        </dd>
        <dt>Overfitting</dt>
        <dd><p>Overfitting occurs when a statistical model describes random error
            or noise instead of the underlying relationship. Overfitting generally
            occurs when a model is excessively complex, such as having too many
            parameters relative to the number of observations. A model which has
            been overfit will generally have poor predictive performance, as it can
            exaggerate minor fluctuations in the data.</p>

            <p>The potential for overfitting depends not only on the number of parameters
            and data but also the conformability of the model structure with the data
            shape, and the magnitude of model error compared to the expected level
            of noise or error in the data.</p>

            <p>In order to avoid overfitting, it is necessary to use additional techniques
            (e.g. cross-validation, regularization, early stopping, pruning, Bayesian
            priors on parameters or model comparison), that can indicate when further
            training is not resulting in better generalization. The basis of some
            techniques is either (1) to explicitly penalize overly complex models,
            or (2) to test the model's ability to generalize by evaluating its
            performance on a set of data not used for training, which is assumed to
            approximate the typical unseen data that a model will encounter.</p>
        </dd>
        <dt>Regularization</dt>
        <dd><p>Regularization involves introducing additional information in order
            to solve an ill-posed problem or to prevent over-fitting. This information
            is usually of the form of a penalty for complexity, such as restrictions
            for smoothness or bounds on the vector space norm.
            A theoretical justification for regularization is that it attempts to impose
            Occam's razor on the solution. From a Bayesian point of view, many
            regularization techniques correspond to imposing certain prior distributions
            on model parameters.</p>
        </dd>
        <dt>Bias-variance tradeoff</dt>
        <dd><p>Mean squared error (MSE) can be broken down into two components:
            variance and squared bias, known as the bias-variance decomposition.
            Thus in order to minimize the MSE, we need to minimize both the bias and
            the variance. However, this is not trivial. Therefore, there is a tradeoff
            between bias and variance.</p>
        </dd>
    </dl>

    <h2 id="knn">K-Nearest Neighbor</h2>

    <p>The k-nearest neighbor algorithm (k-NN) is
        a method for classifying objects by a majority vote of its neighbors,
        with the object being assigned to the class most common amongst its k
        nearest neighbors (k is typically small).
        k-NN is a type of instance-based learning, or lazy learning where the
        function is only approximated locally and all computation
        is deferred until classification.</p>

    <pre class="prettyprint lang-scala"><code>
    def knn(x: Array[Array[Double]], y: Array[Int], k: Int): KNN[Array[Double]]
    </code></pre>

    <p>The simplest k-NN method takes a data set of feature vectors and labels
        with Euclidean distance as the similarity measure. When applied to the
        Iris datset, the accuracy of 10-fold cross validation is 96% for <code>k = 3</code>.</p>

    <pre class="prettyprint lang-scala"><code>
    val iris = readArff("data/weka/iris.arff", 4)
    val (x, y) = iris.unzipInt
    cv(x, y, 10) { case (x, y) => knn(x, y, 3) }
    </code></pre>

    <p>The best choice of k depends upon the data; generally, larger values of
        k reduce the effect of noise on the classification, but make boundaries
        between classes less distinct. A good k can be selected by various
        heuristic techniques, e.g. cross-validation. In binary problems, it is
        helpful to choose k to be an odd number as this avoids tied votes.</p>

    <p>The nearest neighbor algorithm has some strong consistency results. As
        the amount of data approaches infinity, the algorithm is guaranteed to
        yield an error rate no worse than twice the Bayes error rate (the minimum
        achievable error rate given the distribution of the data). k-NN is
        guaranteed to approach the Bayes error rate, for some value of k (where k
        increases as a function of the number of data points).</p>

    <p>The user can also provide a customized distance function.</p>

    <pre class="prettyprint lang-scala"><code>
    def knn[T](x: Array[T], y: Array[Int], distance: Distance[T], k: Int): KNN[T]
    </code></pre>

    <p>Often, the classification accuracy of k-NN can be improved significantly
        if the distance metric is learned with specialized algorithms such as
        Large Margin Nearest Neighbor or Neighborhood Components Analysis.</p>
        
    <p>Alternatively, the user may provide a k-nearest neighbor search data
        structure. Besides the simple linear search, Smile provides KD-Tree,
        Cover Tree, and LSH (Locality-Sensitive Hashing) for efficient
        k-nearest neighbor search.</p>

    <pre class="prettyprint lang-scala"><code>
    def knn[T](x: KNNSearch[T, T], y: Array[Int], k: Int): KNN[T]
    </code></pre>

    <p>A KD-tree (short for k-dimensional tree) is a space-partitioning dataset
        structure for organizing points in a k-dimensional space. Cover tree
        is a data structure for generic nearest neighbor search (with a metric),
        which is especially efficient in spaces with small intrinsic dimension.
        The cover tree has a theoretical bound that is based on the dataset's
        doubling constant. LSH is an efficient algorithm for approximate nearest
        neighbor search in high dimensional spaces by performing probabilistic
        dimension reduction of data.</p>

    <p>Nearest neighbor rules in effect compute the decision boundary in an
        implicit manner. In the following example, we show the implicit decision
        boundary of k-NN on a 2-dimensional toy data. Please try different <code>k</code>,
        and you will observe the change of decision boundary. In general, the larger
        <code>k</code>, the smoother the boundary.</p>

    <pre class="prettyprint lang-scala"><code>
    val toy = readTable2("classification/toy/toy-train.txt", new NominalAttribute("class"), 0)
    val (x, y) = toy.unzipInt
    plot(x, y, knn(x, y, 3)
    </code></pre>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/knn.png" class="enlarge" style="width: 480px;" />
    </div>

    <p>In what follows, we will discuss the classification
        methods that compute the decision boundary explicitly.
        The computational complexity in the prediction phase
        is therefore a function of the boundary complexity.
        We will start with the simplest linear decision functions.</p>

    <h2 id="lda">Linear Discriminant Analysis</h2>

    <p>Linear discriminant analysis (LDA) is based on the Bayes decision theory
        and assumes that the conditional probability density functions are normally
        distributed. LDA also makes the simplifying homoscedastic assumption (i.e.
        that the class covariances are identical) and that the covariances have full
        rank. With these assumptions, the discriminant function of an input being
        in a class is purely a function of this linear combination of independent
        variables.</p>

    <pre class="prettyprint lang-scala"><code>
    def lda(x: Array[Array[Double]], y: Array[Int], priori: Array[Double] = null, tol: Double = 0.0001): LDA
    </code></pre>

    <p>The parameter <code>priori</code> is the priori probability of each class. If null, it will be
        estimated from the training data. The parameter <code>tol</code> is a tolerance to decide
        if a covariance matrix is singular. The function will reject variables whose variance is
        less than tol<sup>2</sup>.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/lda.png" class="enlarge" style="width: 480px;" />
    </div>

    <p>As shown in the plot of toy data, the decision boundary of LDA is linear. Note that
        the decision boundary in the plot is the estimated contour on the testing grid (small dots)
        rather than the exact decision function. Therefore, there are the artifacts caused by
        discretized grid.</p>

    <p>LDA is closely related to ANOVA (analysis of variance) and linear regression
        analysis, which also attempt to express one dependent variable as a
        linear combination of other features or measurements. In the other two
        methods, however, the dependent variable is a numerical quantity, while
        for LDA it is a categorical variable (i.e. the class label). Logistic
        regression and probit regression are more similar to LDA, as they also
        explain a categorical variable. These other methods are preferable in
        applications where it is not reasonable to assume that the independent
        variables are normally distributed, which is a fundamental assumption
        of the LDA method.</p>

    <p>One complication in applying LDA (and Fisher's discriminant) to real data
        occurs when the number of variables/features does not exceed
        the number of samples. In this case, the covariance estimates do not have
        full rank, and so cannot be inverted. This is known as small sample size
        problem.</p>

    <h2 id="fld">Fisher's Linear Discriminant</h2>

    <p>Fisher's linear discriminant (FLD) is another popular linear classifier.
        Fisher defined the separation between two
        distributions to be the ratio of the variance between the classes to
        the variance within the classes, which is, in some sense, a measure
        of the signal-to-noise ratio for the class labeling. FLD finds a linear
        combination of features which maximizes the separation after the projection.
        The resulting combination may be used for dimensionality reduction
        before later classification.</p>

    <pre class="prettyprint lang-scala"><code>
    def fisher(x: Array[Array[Double]], y: Array[Int], L: Int = -1, tol: Double = 0.0001): FLD
    </code></pre>

    <p>The parameter <code>L</code> is the dimensionality of mapped space.
        The default value is the number of classes - 1.</p>

    <p>In FLD, the features are mapped to the subspace spanned by the eigenvectors
        corresponding to the <code>C − 1</code> largest eigenvalues of
        <code>&Sigma;<sup>-1</sup>&Sigma;<sub>b</sub></code>,
        where <code>&Sigma;</code> is the covariance matrix,
        <code>&Sigma;<sub>b</sub></code> is the scatter matrix between class means,
        and <code>C</code> is the number of classes.</p>

    <p>The terms Fisher's linear discriminant and LDA are often used
        interchangeably, although FLD actually describes a slightly different
        discriminant, which does not make some of the assumptions of LDA such
        as normally distributed classes or equal class covariances.
        When the assumptions of LDA are satisfied, FLD is equivalent to LDA.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/fld.png" class="enlarge" style="width: 480px;" />
    </div>

    <p>FLD is also closely related to principal component analysis (PCA), which also
        looks for linear combinations of variables which best explain the data.
        As a supervised method, FLD explicitly attempts to model the
        difference between the classes of data. On the other hand, PCA is a
        unsupervised method and does not take into account any difference in class.</p>

    <p>One complication in applying FLD (and LDA) to real data
        occurs when the number of variables/features does not exceed
        the number of samples. In this case, the covariance estimates do not have
        full rank, and so cannot be inverted. This is known as small sample size
        problem.</p>

    <h2 id="qda">Quadratic Discriminant analysis</h2>

    <p>Quadratic discriminant analysis (QDA) is closely related to LDA.
        Like LDA, QDA models the conditional probability density
        functions as a Gaussian distribution, then uses the posterior distributions
        to estimate the class for a given test data.</p>

    <pre class="prettyprint lang-scala"><code>
    def qda(x: Array[Array[Double]], y: Array[Int], priori: Array[Double] = null, tol: Double = 0.0001): QDA
    </code></pre>

    <p>Unlike LDA, however, in QDA there is no assumption that the covariance of each of the classes
        is identical. Therefore, the resulting separating surface between
        the classes is quadratic.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/qda.png" class="enlarge" style="width: 480px;" />
    </div>

    <p>The Gaussian parameters for each class can be estimated from training data
        with maximum likelihood (ML) estimation. However, when the number of
        training instances is small compared to the dimension of input space,
        the ML covariance estimation can be ill-posed. One approach to resolve
        the ill-posed estimation is to regularize the covariance estimation
        as in regularized discriminant analysis.</p>

    <h2 id="rda">Regularized Discriminant Analysis</h2>

    <p>In LDA and FLD, the eigenvectors corresponding to the smaller eigenvalues will
        tend to be very sensitive to the exact choice of training data, and it is often
        necessary to use regularization. In the regularized discriminant analysis (RDA),
        the regularized covariance matrices of each class is
        &Sigma;<sub>k</sub>(&alpha;) = &alpha; &Sigma;<sub>k</sub> + (1 - &alpha;) &Sigma;.</p>

    <pre class="prettyprint lang-scala"><code>
    def rda(x: Array[Array[Double]], y: Array[Int], alpha: Double, priori: Array[Double] = null, tol: Double = 0.0001): RDA
    </code></pre>

    <p>where the parameter <code>alpha</code> is the regularization factor in <code>[0, 1]</code>.</p>

    <p>RDA is a compromise between LDA and QDA, which allows one to shrink the separate covariances of QDA toward a common
        variance as in LDA. This method is very similar in flavor to ridge regression.
        The quadratic discriminant function is defined using the shrunken covariance
        matrices &Sigma;<sub>k</sub>(&alpha;). The parameter &alpha; in [0, 1]
        controls the complexity of the model. When &alpha; is one, RDA becomes QDA.
        While &alpha; is zero, RDA is equivalent to LDA. Therefore, the
        regularization factor &alpha; allows a continuum of models between LDA and QDA.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/rda.png" class="enlarge" style="width: 480px;" />
    </div>

    <h2 id="logit">Logistic Regression</h2>

    <p>Logistic regression (logit model) is a generalized
        linear model used for binomial regression. Logistic regression applies
        maximum likelihood estimation after transforming the dependent into
        a logit variable. A logit is the natural log of the odds of the dependent
        equaling a certain value or not (usually 1 in binary logistic models,
        the highest value in multinomial models). In this way, logistic regression
        estimates the odds of a certain event (value) occurring.</p>

    <pre class="prettyprint lang-scala"><code>
    def logit(x: Array[Array[Double]], y: Array[Int], lambda: Double = 0.0, tol: Double = 1E-5, maxIter: Int = 500): LogisticRegression
    </code></pre>

    <p>where the parameter <code>lambda (&gt; 0)</code> gives a "regularized" estimate of linear
        weights which often has superior generalization performance, especially
        when the dimensionality is high.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/logit.png" class="enlarge" style="width: 480px;" />
    </div>

    <p>Logistic regression has many analogies to ordinary least squares (OLS)
        regression. Unlike OLS regression, however, logistic regression does not
        assume linearity of relationship between the raw values of the independent
        variables and the dependent, does not require normally distributed variables,
        does not assume homoscedasticity, and in general has less stringent
        requirements.</p>

    <p>Compared with linear discriminant analysis, logistic regression has several
        advantages:</p>

    <ul>
        <li>It is more robust: the independent variables don't have to be normally
            distributed, or have equal variance in each group</li>

        <li>It does not assume a linear relationship between the independent
            variables and dependent variable.</li>

        <li>It may handle nonlinear effects since one can add explicit interaction
            and power terms.</li>
    </ul>

    <p>However, it requires much more data to achieve stable, meaningful results.</p>

    <p>Logistic regression also has strong connections with neural network and
         maximum entropy modeling. For example, binary logistic regression is
         equivalent to a one-layer, single-output neural network with a logistic
         activation function trained under log loss. Similarly, multinomial logistic
         regression is equivalent to a one-layer, softmax-output neural network.</p>

    <p>Logistic regression estimation also obeys the maximum entropy principle, and
         thus logistic regression is sometimes called "maximum entropy modeling",
         and the resulting classifier the "maximum entropy classifier".</p>

    <h2 id="maxent">Maximum Entropy Classifier</h2>

    <p>Maximum entropy is a technique for learning
        probability distributions from data. In maximum entropy models, the
        observed data itself is assumed to be the testable information. Maximum
        entropy models don't assume anything about the probability distribution
        other than what have been observed and always choose the most uniform
        distribution subject to the observed constraints.</p>

    <pre class="prettyprint lang-scala"><code>
    def maxent(x: Array[Array[Int]], y: Array[Int], p: Int, lambda: Double = 0.1, tol: Double = 1E-5, maxIter: Int = 500): Maxent
    </code></pre>

    <p>where <code>x</code> is the sparse training samples. Each sample is represented by a set of sparse
        binary features. The features are stored in an integer array, of which
        are the indices of nonzero features.
        The parameter <code>p</code> is the dimension of feature space, and <code>lambda</code>
        is the regularization factor.</p>

    <p>Basically, maximum entropy classifier is another name of multinomial logistic
        regression applied to categorical independent variables, which are
        converted to binary dummy variables. Maximum entropy models are widely
        used in natural language processing. Therefore, our implementation
        assumes that binary features are stored in a sparse array, of which
        entries are the indices of nonzero features.</p>

    <h2 id="neural-network">Multilayer Perceptron Neural Network</h2>

    <p>A multilayer perceptron neural network consists of several layers of nodes, interconnected through weighted
        acyclic arcs from each preceding layer to the following, without lateral or
        feedback connections. Each node calculates a transformed weighted linear
        combination of its inputs (output activations from the preceding layer), with
        one of the weights acting as a trainable bias connected to a constant input.
        The transformation, called activation function, is a bounded non-decreasing
        (non-linear) function, such as the sigmoid functions (ranges from 0 to 1).
        Another popular activation function is hyperbolic tangent which is actually
        equivalent to the sigmoid function in shape but ranges from -1 to 1.
        More specialized activation functions include radial basis functions which
        are used in RBF networks.</p>

    <p>For neural networks, the input patterns usually should be scaled/standardized.
        Commonly, each input variable is scaled into interval [0, 1] or to have
        mean 0 and standard deviation 1.</p>

    <pre class="prettyprint lang-scala"><code>
    def neuralnet(x: Array[Array[Double]], y: Array[Int], numUnits: Array[Int], error: NeuralNetwork.ErrorFunction, activation: NeuralNetwork.ActivationFunction, epochs: Int = 25, eta: Double = 0.1, alpha: Double = 0.0, lambda: Double = 0.0): NeuralNetwork
    </code></pre>

    <p>where <code>numUnits</code> is the number of units in each layer, <code>error</code>
        is the error function, <code>activation</code> is the activation function of output layer,
        <code>epochs</code> is the number of epochs of stochastic learning,
        <code>eta</code> is the learning rate,
        <code>alpha</code> is the momentum factor,
        and <code>lambda</code> is the weight decay for regularization.
        The meaning of these parameters will be clear in the following discussion.</p>

    <p>For error/penalty functions and output units, the following natural pairings are
        recommended:</p>

    <ul>
        <li>linear output units and a least squares penalty function.</li>

        <li>a two-class cross-entropy penalty function and a logistic
            activation function.</li>

        <li>a multi-class cross-entropy penalty function and a softmax
            activation function.</li>
    </ul>

    <p>By assigning a softmax activation function on the output layer of
        the neural network for categorical target variables, the outputs
        can be interpreted as posterior probabilities, which are very useful.</p>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/neural-network.png" class="enlarge" style="width: 480px;" />
    </div>

    <p>The representational capabilities of a neural network are determined by the range of
        mappings it may implement through weight variation. Single layer perceptrons
        are capable of solving only linearly separable problems. With the sigmoid
        function as activation function, the single-layer network is identical
        to the logistic regression model.</p>

    <p>The universal approximation theorem for neural networks states that every
        continuous function that maps intervals of real numbers to some output
        interval of real numbers can be approximated arbitrarily closely by a
        multi-layer perceptron with just one hidden layer. This result holds only
        for restricted classes of activation functions, which are extremely complex
        and NOT smooth for subtle mathematical reasons. On the other hand, smoothness
        is important for gradient descent learning. Besides, the proof is not
        constructive regarding the number of neurons required or the settings of
        the weights. Therefore, complex systems will have more layers of neurons
        with some having increased layers of input neurons and output neurons
        in practice. The extra layers enable composition of features from lower layers,
        giving the potential of modeling complex data with fewer units than a similarly
        performing shallow network. But many issues can arise with deep neural networks
        if they are naively trained. Two common issues are overfitting and computation time.</p>

    <p>The most popular algorithm to train neural networks is back-propagation, which is a
        gradient descent method. Based on chain rule, the algorithm propagates the
        error back through the network and adjusts the weights of each connection in
        order to reduce the value of the error function by some small amount.
        For this reason, back-propagation can only be applied on networks with
        differentiable activation functions.</p>

    <p>During error back propagation, we usually times the gradient with a small
        number &eta;, called learning rate, which is carefully selected to ensure
        that the network converges to a local minimum of the error function
        fast enough, without producing oscillations. One way to avoid oscillation
        at large &eta;, is to make the change in weight dependent on the past weight
        change by adding a momentum term.</p>

    <p>Although the back-propagation algorithm may performs gradient
        descent on the total error of all instances in a batch way,
        the learning rule is often applied to each instance separately in an online
        way or stochastic way. There exists empirical indication that the stochastic
        way results in faster convergence.</p>

    <p>In practice, the problem of over-fitting has emerged. This arises in
        convoluted or over-specified systems when the capacity of the network
        significantly exceeds the needed free parameters. There are two general
        approaches for avoiding this problem: The first is to use cross-validation
        and similar techniques to check for the presence of over-fitting and
        optimally select hyper-parameters such as to minimize the generalization
        error. The second is to use some form of regularization, which emerges
        naturally in a Bayesian framework, where the regularization can be
        performed by selecting a larger prior probability over simpler models;
        but also in statistical learning theory, where the goal is to minimize over
        the "empirical risk" and the "structural risk".</p>

    <h2 id="rbf-network">Radial Basis Function Networks</h2>

    <p>A radial basis function network is an
        artificial neural network that uses radial basis functions as activation
        functions. It is a linear combination of radial basis functions. They are
        used in function approximation, time series prediction, and control.</p>

    <p>In its basic form, radial basis function network is in the form</p>

    <pre class="prettyprint lang-scala"><code>
    y(x) = &Sigma; w<sub>i</sub> &phi;(||x-c<sub>i</sub>||)
    </code></pre>

    <p>where the approximating function y(x) is represented as a sum of N radial
        basis functions &phi;, each associated with a different center c<sub>i</sub>,
        and weighted by an appropriate coefficient w<sub>i</sub>. For distance,
        one usually chooses Euclidean distance. The weights w<sub>i</sub> can
        be estimated using the matrix methods of linear least squares, because
        the approximating function is linear in the weights.</p>

    <p>The centers c<sub>i</sub> can be randomly selected from training data,
        or learned by some clustering method (e.g. k-means), or learned together
        with weight parameters undergo a supervised learning processing
        (e.g. error-correction learning).</p>

    <pre class="prettyprint lang-scala"><code>
    def rbfnet[T](x: Array[T], y: Array[Int], distance: Metric[T], rbf: RadialBasisFunction, centers: Array[T]): RBFNetwork[T]

    def nrbfnet[T](x: Array[T], y: Array[Int], distance: Metric[T], rbf: RadialBasisFunction, centers: Array[T]): RBFNetwork[T]

    def rbfnet[T](x: Array[T], y: Array[Int], distance: Metric[T], rbf: Array[RadialBasisFunction], centers: Array[T]): RBFNetwork[T]

    def nrbfnet[T](x: Array[T], y: Array[Int], distance: Metric[T], rbf: Array[RadialBasisFunction], centers: Array[T]): RBFNetwork[T]
    </code></pre>

    <p>The popular choices for &phi; comprise the Gaussian function and the so
        called thin plate splines. The advantage of the thin plate splines is that
        their conditioning is invariant under scalings. Gaussian, multi-quadric
        and inverse multi-quadric are infinitely smooth and and involve a scale
        or shape parameter, r<sub><small>0</small></sub> &gt; 0. Decreasing
        r<sub><small>0</small></sub> tends to flatten the basis function. For a
        given function, the quality of approximation may strongly depend on this
        parameter. In particular, increasing r<sub><small>0</small></sub> has the
        effect of better conditioning (the separation distance of the scaled points
        increases).</p>

    <pre class="prettyprint lang-scala"><code>
    val centers = new Array[Array[Double]](50)
    val basis = gaussrbf(x, centers)
    val classifier = rbfnet(x, y, new EuclideanDistance, basis, centers)
    plot(x, y, classifier)
    </code></pre>

    <div style="width: 100%; display: inline-block; text-align: center;">
        <img src="images/rbf-network.png" class="enlarge" style="width: 480px;" />
    </div>

    <p>A variant on RBF networks is normalized radial basis function (NRBF)
        networks, in which we require the sum of the basis functions to be unity.
        NRBF arises more naturally from a Bayesian statistical perspective. However,
        there is no evidence that either the NRBF method is consistently superior
        to the RBF method, or vice versa.</p>

    <p>SVMs with Gaussian kernel have similar structure as RBF networks with
        Gaussian radial basis functions. However, the SVM approach "automatically"
        solves the network complexity problem since the size of the hidden layer
        is obtained as the result of the QP procedure. Hidden neurons and
        support vectors correspond to each other, so the center problems of
        the RBF network is also solved, as the support vectors serve as the
        basis function centers. It was reported that with similar number of support
        vectors/centers, SVM shows better generalization performance than RBF
        network when the training data size is relatively small. On the other hand,
        RBF network gives better generalization performance than SVM on large
        training data.</p>

    <h2 id="svm">Support Vector Machines</h2>

    <p>The basic support vector machine (SVM)
        is a binary linear classifier which chooses the hyperplane that represents
        the largest separation, or margin, between the two classes. If such a
        hyperplane exists, it is known as the maximum-margin hyperplane and the
        linear classifier it defines is known as a maximum margin classifier.</p>

    <p>If there exists no hyperplane that can perfectly split the positive and
        negative instances, the soft margin method will choose a hyperplane
        that splits the instances as cleanly as possible, while still maximizing
        the distance to the nearest cleanly split instances.</p>

    <p>The nonlinear SVMs are created by applying the kernel trick to
        maximum-margin hyperplanes. The resulting algorithm is formally similar,
        except that every dot product is replaced by a nonlinear kernel function.
        This allows the algorithm to fit the maximum-margin hyperplane in a
        transformed feature space. The transformation may be nonlinear and
        the transformed space be high dimensional. For example, the feature space
        corresponding Gaussian kernel is a Hilbert space of infinite dimension.
        Thus though the classifier is a hyperplane in the high-dimensional feature
        space, it may be nonlinear in the original input space. Maximum margin
        classifiers are well regularized, so the infinite dimension does not spoil
        the results.</p>

    <p>The effectiveness of SVM depends on the selection of kernel, the kernel's
        parameters, and soft margin parameter C. Given a kernel, best combination
        of C and kernel's parameters is often selected by a grid-search with
        cross validation.</p>

    <p>The dominant approach for creating multi-class SVMs is to reduce the
        single multi-class problem into multiple binary classification problems.
        Common methods for such reduction is to build binary classifiers which
        distinguish between (i) one of the labels to the rest (one-versus-all)
        or (ii) between every pair of classes (one-versus-one). Classification
        of new instances for one-versus-all case is done by a winner-takes-all
        strategy, in which the classifier with the highest output function assigns
        the class. For the one-versus-one approach, classification
        is done by a max-wins voting strategy, in which every classifier assigns
        the instance to one of the two classes, then the vote for the assigned
        class is increased by one vote, and finally the class with most votes
        determines the instance classification.</p>
</div>

<script type="text/javascript">
    $('#toc').toc({exclude: 'h1, h5, h6', context: '', autoId: true, numerate: false});
</script>